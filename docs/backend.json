{
  "entities": {
    "Client": {
      "title": "Client",
      "type": "object",
      "description": "Represents a client of the tech store.",
      "properties": {
        "name": { "type": "string", "description": "Full name of the client." },
        "cpf": { "type": "string", "description": "CPF (Cadastro de Pessoas Físicas) of the client." },
        "phone": { "type": "string", "description": "Phone number/WhatsApp of the client." },
        "address": { "type": "string", "description": "Full address of the client." },
        "notes": { "type": "string", "description": "Additional notes about the client." },
        "createdAt": { "type": "string", "format": "date-time", "description": "Timestamp indicating when the client was created." }
      },
      "required": ["name", "phone"]
    },
    "Transaction": {
      "title": "Transaction",
      "type": "object",
      "description": "Represents a financial transaction (income or expense).",
      "properties": {
        "type": { "type": "string", "enum": ["income", "expense"], "description": "Type of transaction." },
        "description": { "type": "string", "description": "Description of the transaction." },
        "amount": { "type": "number", "description": "Amount of the transaction." },
        "date": { "type": "string", "format": "date-time", "description": "Date of the transaction." },
        "owner": { "type": "string", "enum": ["admin", "pedro", "split"], "description": "Owner of the transaction for profit splitting." },
        "clientId": { "type": "string", "description": "Reference to a client document." },
        "clientName": { "type": "string", "description": "Denormalized client name for quick display." }
      },
      "required": ["type", "description", "amount", "date", "owner"]
    },
    "Product": {
      "title": "Product",
      "type": "object",
      "description": "Represents an item in the store's inventory.",
      "properties": {
        "name": { "type": "string", "description": "Name of the product." },
        "quantity": { "type": "number", "description": "Quantity in stock." },
        "costPrice": { "type": "number", "description": "The price at which the product was purchased." },
        "sellingPrice": { "type": "number", "description": "The price at which the product is sold." },
        "supplierName": { "type": "string", "description": "Name of the supplier." },
        "supplierPhone": { "type": "string", "description": "Phone number of the supplier." },
        "createdAt": { "type": "string", "format": "date-time", "description": "Timestamp indicating when the product was added." }
      },
      "required": ["name", "quantity", "costPrice", "sellingPrice"]
    },
    "ServiceOrder": {
      "title": "ServiceOrder",
      "type": "object",
      "description": "Represents a service order for a client's equipment.",
      "properties": {
        "clientId": { "type": "string", "description": "Reference to the client document." },
        "clientName": { "type": "string", "description": "Denormalized client name." },
        "equipment": { "type": "string", "description": "Description of the equipment being serviced." },
        "problemDescription": { "type": "string", "description": "The problem reported by the client." },
        "entryDate": { "type": "string", "format": "date-time", "description": "Date the equipment was received." },
        "status": { "type": "string", "enum": ["Em Análise", "Aguardando Aprovação", "Em Manutenção", "Pronto para Retirada", "Finalizado/Entregue"], "description": "Current status of the service order." },
        "notes": { "type": "string", "description": "Internal notes about the service." },
        "items": {
          "type": "array",
          "description": "List of services and parts used.",
          "items": {
            "type": "object",
            "properties": {
              "description": { "type": "string" },
              "quantity": { "type": "number" },
              "unitPrice": { "type": "number" }
            },
            "required": ["description", "quantity", "unitPrice"]
          }
        },
        "finalValue": { "type": "number", "description": "Total value of the service order." },
        "createdAt": { "type": "string", "format": "date-time", "description": "Timestamp for creation." }
      },
      "required": ["clientId", "clientName", "equipment", "entryDate", "status", "items", "finalValue"]
    }
  },
  "auth": {
    "providers": ["anonymous"]
  },
  "firestore": {
    "structure": [
      {
        "path": "clients/{clientId}",
        "definition": {
          "entityName": "Client",
          "schema": { "$ref": "#/entities/Client" },
          "description": "Stores all client information.",
          "params": [{ "name": "clientId", "description": "Unique identifier for the client." }]
        }
      },
      {
        "path": "transactions/{transactionId}",
        "definition": {
          "entityName": "Transaction",
          "schema": { "$ref": "#/entities/Transaction" },
          "description": "Stores all financial transactions (income/expense).",
          "params": [{ "name": "transactionId", "description": "Unique identifier for the transaction." }]
        }
      },
      {
        "path": "products/{productId}",
        "definition": {
          "entityName": "Product",
          "schema": { "$ref": "#/entities/Product" },
          "description": "Stores all inventory products.",
          "params": [{ "name": "productId", "description": "Unique identifier for the product." }]
        }
      },
      {
        "path": "serviceOrders/{serviceOrderId}",
        "definition": {
          "entityName": "ServiceOrder",
          "schema": { "$ref": "#/entities/ServiceOrder" },
          "description": "Stores all service orders.",
          "params": [{ "name": "serviceOrderId", "description": "Unique identifier for the service order." }]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed for simplicity and scalability. Each core entity (Client, Transaction, Product, ServiceOrder) has its own top-level collection. This approach ensures that queries are simple and security rules can be applied granularly to each data type. Denormalization is used sparingly (e.g., `clientName` in transactions and service orders) to simplify read operations without adding significant write complexity. All operations are secured by requiring an authenticated user, which aligns with the application's internal management tool nature. This structure supports all current features while being flexible enough for future expansion."
  }
}
